## 인덱스(Index)란?

<b>데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조</b>

key-value 형태로 정렬되어 빠른 데이터 접근을 가능하게 함.

도서관의 목차와 같은 역할로 전체 데이터를 스캔하지 않고도 원하는 정보를 신속하게 찾을 수 있게 도와줌.

### 인덱스의 작동 원리

B-Tree, B+Tree 등의 자료구조 사용

B+Tree는 모든 데이터가 리프 노드에만 존재하고 내부 노드는 인덱스 역할만 수행하여 검색 효율성이 높음

O(log n)로 검색 수행

### 모든 컬럼에 인덱스를 지정하지 않는 이유

- 추가 저장공간 필요

인덱스는 별도의 자료구조로 저장
원본 데이터 외에 추가 공간 사용
경우에 따라 테이블 용량보다 인덱스 용량이 커질 수 있음


- 쓰기 성능 저하

데이터 변경 시 인덱스도 함께 업데이트 필요
인덱스가 많을수록 INSERT, UPDATE, DELETE 연산 비용 증가
트랜잭션 처리량 감소


- 인덱스 관리 비용

인덱스 파편화
주기적인 인덱스 재구성 필요
데이터베이스 관리 복잡성 증가


### 수정, 삽입이 자주 일어나지 않는 테이블에 인덱스를 걸면 좋은 이유

읽기 작업이 대부분인 경우 검색 성능 향상
쓰기 작업이 적어 인덱스 유지 비용 최소화
대규모 데이터에서 특히 효과적
복잡한 조인이나 범위 검색 시 성능 이점 극대화


### PK와 인덱스

기본키(Primary Key)는 자동으로 인덱스 생성
유일성과 NOT NULL 제약조건을 가짐
대부분의 DBMS에서 PK는 클러스터 인덱스로 구성


## 클러스터 인덱스 vs 논 클러스터 인덱스

- 클러스터 인덱스 개념
클러스터 인덱스는 데이터 자체를 인덱스 키 순서대로 물리적으로 정렬하여 저장하는 방식. 
테이블당 하나만 존재 가능하며 리프 노드가 곧 데이터 페이지.

- 논 클러스터 인덱스 개념
논 클러스터 인덱스는 데이터와 별도로 인덱스 구조만 정렬하여 유지하는 방식. 
책 뒤의 색인 페이지처럼 키워드와 페이지 번호를 매핑한 형태로, 여러 개 생성 가능. 


### 클러스터 인덱스(Clustered Index)

테이블당 하나만 존재 가능
실제 데이터 행을 인덱스 키 순서대로 물리적으로 정렬
데이터 페이지 자체가 정렬되어 저장
리프 노드가 실제 데이터 페이지

### 논 클러스터 인덱스(Non-Clustered Index)

테이블당 여러 개 생성 가능
실제 데이터와 별도로 인덱스만 정렬
리프 노드에 실제 데이터 위치를 가리키는 포인터 저장
논리적 순서만 제공

### 성능 차이

클러스터 인덱스: 범위 검색에 유리, 데이터 접근 속도 빠름
논 클러스터 인덱스: 추가 조회 필요, 데이터 변경 시 더 효율적


클러스터 인덱스는 데이터 순차 접근에 최적화
논 클러스터 인덱스는 단일 행 조회에 효율적