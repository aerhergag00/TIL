# 동시성 제어 메커니즘

### 동시성 제어가 필요한 이유
- 동일 데이터에 대한 동시 수정 시 데이터 일관성 깨짐
- 예시: 좌석 예약, 재고 관리, 포인트 차감 등
- 해결책: 락(Lock)을 통한 순차적 접근 제어

### 락 종류별 특징과 사용

#### 1. 낙관적 락(Optimistic Lock)
- **원리**: 버전 관리를 통한 충돌 감지
- **사용**: 읽기가 많고 수정이 적은 경우
- **장점**: 성능 좋음, Dead Lock 없음
- **단점**: 충돌 시 재시도 필요

```java
@Entity
public class Account {
    @Version
    private Long version;  // 수정마다 자동 증가
    private Long balance;
}
```

#### 2. 비관적 락(Pessimistic Lock)
- **원리**: DB 수준의 배타적/공유 락
- **사용**: 수정이 빈번한 경우
- **장점**: 충돌 없음, 강한 정합성
- **단점**: 성능 저하, Dead Lock 가능성

```sql
SELECT * FROM account WHERE id = 1 FOR UPDATE;  -- 배타락
```

#### 3. 분산 락(Distributed Lock)
- **원리**: Redis 등으로 분산 환경 락 관리
- **사용**: MSA, 다중 서버 환경
- **주의**: 장애 대비 TTL 설정 필수

### 실제 적용 시나리오
1. **좌석 예약**
   - 낮은 트래픽: 낙관적 락
   - 높은 트래픽: 비관적 락
   - 다중 서버: 분산 락

2. **결제/포인트**
   - 비관적 락 + 트랜잭션
   - 멱등성 처리로 중복 방지

- 락 타임아웃 설정 필수
- 데드락 방지를 위한 락 획득 순서 정의
- 성능과 정합성 사이 트레이드오프 고려