# JPA에서의 N+1 문제 이해와 해결 전략 설정

## N+1 문제란?
> 연관 관계에서 발생하는 성능 문제 중 하나로, 1번의 쿼리로 N개의 결과를 가져왔을 때 N개의 추가 쿼리가 발생하는 현상.

## 발생 원인 이해

### 1. 즉시 로딩(EAGER)에서의 발생

- 엔티티를 조회할 때 연관된 엔티티를 항상 함께 조회
- JPQL에서 SQL로 변환 시 조인이 아닌 단일 쿼리로 변환되어 추가 쿼리 발생

### 2. 지연 로딩(LAZY)에서의 발생

- 연관된 엔티티를 실제 사용할 때 쿼리 발생
- 컬렉션을 순회하면서 각각의 연관 엔티티를 조회할 때 추가 쿼리 발생

## 문제가 심각한 상황

- 대량의 데이터를 조회할 때
- 연관 관계가 복잡한 도메인 구조
- API 응답 시 연관 데이터가 필요한 경우
- 실시간 서비스에서 응답 시간이 중요한 경우

## 해결 방안
### 1. Fetch Join

가장 일반적인 해결책이다.


JPQL의 join fetch를 사용하여 한 번의 쿼리로 연관된 엔티티를 함께 조회

단점: 페이징 처리가 어렵고, 여러 테이블을 조인할 경우 데이터 중복 발생 가능

### 2. EntityGraph

Fetch Join보다 간단한 방법

@EntityGraph 어노테이션으로 같이 조회할 연관 엔티티 지정
내부적으로는 Fetch Join과 동일한 방식으로 동작

###### EntityGraph의 단점은?
- 연관 관계가 깊을수록 제어가 어려움
- 일대다 관계에서 페이징 시 모든 데이터를 메모리에 로딩
- 데이터가 많으면 메모리 부족의 발생 위험


### 3. BatchSize 설정

연관된 엔티티를 조회할 때 지정된 size만큼 in 절로 한 번에 조회
N+1 문제를 N+1번에서 1+1번으로 최적화
전역 설정이 가능하여 편리함

###### BatchSize의 단점은?
- 여전히 추가 쿼리가 생기고 N+1문제를 완전히 해결한 것이 아님
- 최적화의 어려움

## 해결방안 선택 기준
### 1. Fetch Join 선택할 때

- 항상 연관 엔티티가 필요한 경우
- 단일 테이블 조인이며 페이징이 필요없는 경우
- 데이터 정합성이 중요한 경우

### 2. BatchSize 선택할 때

- 페이징이 필요한 경우
- 여러 테이블을 조인해야 하는 경우
- 상황에 따라 연관 엔티티가 필요한 경우

### 3. EntityGraph 선택할 때

- 간단한 조인이 필요한 경우
- 동적으로 연관 관계 선택이 필요한 경우

## 실제 적용 시 고려사항

### 1. 비즈니스 요구사항 파악

- 실시간성이 중요한지
- 데이터의 정합성이 중요한지
- 페이징이 필요한지

### 2. 성능 모니터링

- 쿼리 실행 계획 확인
- 실제 성능 측정
- 데이터 양이 증가했을 때의 영향도 파악

### 3. 트레이드오프 고려

- 메모리 사용량 vs 쿼리 수행 시간
- 코드 복잡도 vs 성능
- 유지보수 용이성 vs 최적화 정도


## 정리
N+1 문제는 JPA를 사용할 때 흔히 발생하는 성능 문제이다.
문제 상황을 정확히 이해하고 각 해결방안의 장단점을 파악하여 적절한 해결책을 선택하는 것이 중요. 
실무에서는 하나의 해결책만 고집하지 말고, 상황에 따라 적절한 방법을 선택하여 사용해야 하는 것이 좋다.